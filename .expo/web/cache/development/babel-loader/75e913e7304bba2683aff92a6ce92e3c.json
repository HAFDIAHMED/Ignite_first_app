{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEnvironment = createEnvironment;\nexports.setupRootStore = setupRootStore;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _mobxStateTree = require(\"mobx-state-tree\");\n\nvar _rootStore = require(\"./root-store\");\n\nvar _environment = require(\"../environment\");\n\nvar storage = _interopRequireWildcard(require(\"../../utils/storage\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar ROOT_STATE_STORAGE_KEY = \"root\";\n\nfunction createEnvironment() {\n  var env;\n  return _regenerator.default.async(function createEnvironment$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          env = new _environment.Environment();\n          _context.next = 3;\n          return _regenerator.default.awrap(env.setup());\n\n        case 3:\n          return _context.abrupt(\"return\", env);\n\n        case 4:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nfunction setupRootStore() {\n  var rootStore, data, env;\n  return _regenerator.default.async(function setupRootStore$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return _regenerator.default.awrap(createEnvironment());\n\n        case 2:\n          env = _context2.sent;\n          _context2.prev = 3;\n          _context2.next = 6;\n          return _regenerator.default.awrap(storage.load(ROOT_STATE_STORAGE_KEY));\n\n        case 6:\n          _context2.t0 = _context2.sent;\n\n          if (_context2.t0) {\n            _context2.next = 9;\n            break;\n          }\n\n          _context2.t0 = {};\n\n        case 9:\n          data = _context2.t0;\n          rootStore = _rootStore.RootStoreModel.create(data, env);\n          _context2.next = 17;\n          break;\n\n        case 13:\n          _context2.prev = 13;\n          _context2.t1 = _context2[\"catch\"](3);\n          rootStore = _rootStore.RootStoreModel.create({}, env);\n          __DEV__ && console.tron.error(_context2.t1.message, null);\n\n        case 17:\n          if (__DEV__) {\n            env.reactotron.setRootStore(rootStore, data);\n          }\n\n          (0, _mobxStateTree.onSnapshot)(rootStore, function (snapshot) {\n            return storage.save(ROOT_STATE_STORAGE_KEY, snapshot);\n          });\n          return _context2.abrupt(\"return\", rootStore);\n\n        case 20:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, [[3, 13]], Promise);\n}","map":{"version":3,"sources":["C:/Users/ahafdi/Desktop/react native/ignite/PizzaApp/app/models/root-store/setup-root-store.ts"],"names":["ROOT_STATE_STORAGE_KEY","createEnvironment","env","Environment","setup","setupRootStore","storage","load","data","rootStore","RootStoreModel","create","__DEV__","console","tron","error","message","reactotron","setRootStore","snapshot","save"],"mappings":";;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;AAKA,IAAMA,sBAAsB,GAAG,MAA/B;;AASO,SAAeC,iBAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AACCC,UAAAA,GADD,GACO,IAAIC,wBAAJ,EADP;AAAA;AAAA,4CAECD,GAAG,CAACE,KAAJ,EAFD;;AAAA;AAAA,2CAGEF,GAHF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA,SAAeG,cAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,4CAKaJ,iBAAiB,EAL9B;;AAAA;AAKCC,UAAAA,GALD;AAAA;AAAA;AAAA,4CAQWI,OAAO,CAACC,IAAR,CAAaP,sBAAb,CARX;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA,yBAQoD,EARpD;;AAAA;AAQHQ,UAAAA,IARG;AASHC,UAAAA,SAAS,GAAGC,0BAAeC,MAAf,CAAsBH,IAAtB,EAA4BN,GAA5B,CAAZ;AATG;AAAA;;AAAA;AAAA;AAAA;AAaHO,UAAAA,SAAS,GAAGC,0BAAeC,MAAf,CAAsB,EAAtB,EAA0BT,GAA1B,CAAZ;AAGAU,UAAAA,OAAO,IAAIC,OAAO,CAACC,IAAR,CAAaC,KAAb,CAAmB,aAAEC,OAArB,EAA8B,IAA9B,CAAX;;AAhBG;AAoBL,cAAIJ,OAAJ,EAAa;AACXV,YAAAA,GAAG,CAACe,UAAJ,CAAeC,YAAf,CAA4BT,SAA5B,EAAuCD,IAAvC;AACD;;AAGD,yCAAWC,SAAX,EAAsB,UAAAU,QAAQ;AAAA,mBAAIb,OAAO,CAACc,IAAR,CAAapB,sBAAb,EAAqCmB,QAArC,CAAJ;AAAA,WAA9B;AAzBK,4CA2BEV,SA3BF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","sourcesContent":["import { onSnapshot } from \"mobx-state-tree\"\nimport { RootStoreModel, RootStore } from \"./root-store\"\nimport { Environment } from \"../environment\"\nimport * as storage from \"../../utils/storage\"\n\n/**\n * The key we'll be saving our state as within async storage.\n */\nconst ROOT_STATE_STORAGE_KEY = \"root\"\n\n/**\n * Setup the environment that all the models will be sharing.\n *\n * The environment includes other functions that will be picked from some\n * of the models that get created later. This is how we loosly couple things\n * like events between models.\n */\nexport async function createEnvironment() {\n  const env = new Environment()\n  await env.setup()\n  return env\n}\n\n/**\n * Setup the root state.\n */\nexport async function setupRootStore() {\n  let rootStore: RootStore\n  let data: any\n\n  // prepare the environment that will be associated with the RootStore.\n  const env = await createEnvironment()\n  try {\n    // load data from storage\n    data = (await storage.load(ROOT_STATE_STORAGE_KEY)) || {}\n    rootStore = RootStoreModel.create(data, env)\n  } catch (e) {\n    // if there's any problems loading, then let's at least fallback to an empty state\n    // instead of crashing.\n    rootStore = RootStoreModel.create({}, env)\n\n    // but please inform us what happened\n    __DEV__ && console.tron.error(e.message, null)\n  }\n\n  // reactotron logging\n  if (__DEV__) {\n    env.reactotron.setRootStore(rootStore, data)\n  }\n\n  // track changes & save to storage\n  onSnapshot(rootStore, snapshot => storage.save(ROOT_STATE_STORAGE_KEY, snapshot))\n\n  return rootStore\n}\n"]},"metadata":{},"sourceType":"script"}